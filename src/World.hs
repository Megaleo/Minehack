-- | The way to handle "infinite" world elements is, in the
-- nutshell, load 16x16 Tiles chunks with random generation
-- (seed) and verify if any of those have modified tiles.
--
-- This module will care of these world stuff, loading chunks
-- mainly.
--
-- TODO
--
-- @ Add suport for more complex biomes.
-- @ Add transition biomes.

module World where

import Data.Array

import Numeric.Noise
import Numeric.Noise.Perlin

import qualified Tile as T
import qualified Tile.TileType as TT
import qualified Block as B
import qualified Item as I

-- | Type synonyms.
type Coord      = (Int, Int)
type TileCoord  = Coord
type ChunkCoord = Coord
-- | Chunk = Array of Tiles and its coordinates.
type Chunk      = Array TileCoord T.Tile
-- | A tuple of a tile and its coordinates.
type CTile      = (TileCoord, T.Tile)

-- Returns the Chunk coordinates of a Tile.
tileChunk :: TileCoord -> ChunkCoord
tileChunk (x, y) = (new x, new y)
  where
    new var = var `div` 16

-- | The range of tiles coordinates of a Chunk.
chunkRange :: ChunkCoord -> (TileCoord, TileCoord)
chunkRange (x, y) = ((min_ x, min_ y),(max_ x, max_ y))
  where
    min_ = (*) 16
    max_ = (+) 15 . min_

-- | Returns if a tile coordenate is in the chunk's range.
isInChunkRange :: TileCoord -> ChunkCoord -> Bool
isInChunkRange tileC chunkC = tileChunk tileC == chunkC

-- | Generates a 2D map with type Double from a Perlin.
twoD :: Double -> Double -> Perlin -> Double
twoD x y perlin_ = noiseValue perlin_ (x,y,1)

-- | Multiplies by a number all the values of a 16x16 2D map of Perlin generated by
-- "twoD" in some chunk coordinates and rounds all the results.
-- Note: Always perlin noise by itself returns values from -1 to 1.
chunkPMap :: Double -> Perlin -> ChunkCoord -> [Int]
chunkPMap mult perlin_ coord = [round $ mult * (twoD (toEnum x) (toEnum y) perlin_) | (x, y) <- range $ chunkRange coord]

-- | Generates a list of tiles based on the multiplier, perlin and some chunk coordinates
-- for chunkPMap and a function that picks a values in the perlin map and returns a
-- tile. mapping it, genPerlinChunk generates a list of tiles.
genPrimitiveChunk :: Double -> Perlin -> ChunkCoord -> (Int -> T.Tile) -> [T.Tile]
genPrimitiveChunk mult perlin_ cCoord pFunc = map pFunc $ chunkPMap mult perlin_ cCoord

-- | Uses the same technic as in genPrimitiveChunk
-- but it returns a Chunk (Array of Tiles).
genChunk :: Double -> Perlin -> ChunkCoord -> (Int -> T.Tile) -> Chunk
genChunk mult perlin_ cCoord pFunc = array (chunkRange cCoord) $ zip (range $ chunkRange cCoord) (genPrimitiveChunk mult perlin_ cCoord pFunc)

-- | The standart multiplication factor for
-- CPM and biome generation (CPM stands for
-- "Chunk Perlin Map").
stdMult :: Double
stdMult = 100.0

-- | A simple biome is a function that returns a tile
-- given a value on the Chunk Perlin Map, some arguments
-- for Perlin creation and a multiplier.
data SimpleBiome = SBiome { cpmFunc :: Int -> T.Tile     -- ^ Takes a value on the CPM
                          , perlinArgs :: Int -> Perlin  -- ^ Takes a Seed by argument
                          , multiplier :: Double         -- ^ Multiplier for all values
                          }

-- | Generates a list of tiles by applying genPrimitiveChunk
-- handling data from SimpleBiome.
genPrimitiveSBiomeChunk :: Int -> ChunkCoord -> SimpleBiome -> [T.Tile]
genPrimitiveSBiomeChunk seed cCoord sBiome = genPrimitiveChunk mult perlin_ cCoord cpmF
    where
        mult    = multiplier sBiome
        perlin_ = (perlinArgs sBiome) seed
        cpmF    = cpmFunc sBiome

-- | Uses the same technic as in genPrimitiveSBiomeChunk
-- but it returns a Chunk (Array of Tiles).
genSBiomeChunk :: Int -> ChunkCoord -> SimpleBiome -> Chunk
genSBiomeChunk seed cCoord sBiome = array (chunkRange cCoord) $ zip (range $ chunkRange cCoord) (genPrimitiveSBiomeChunk seed cCoord sBiome)

-- | A Simple Forest made out of "Block of Wood",
-- "Item of Wood" and "Air".
simpleForest :: SimpleBiome
simpleForest = SBiome cpmMap perlin_ stdMult
    where
        cpmMap value
          | value < 0  = T.Tile (TT.TBlock B.Air) []
          | value < 10 = T.Tile (TT.TItem I.Wood) []
          | otherwise  = T.Tile (TT.TBlock B.Wood) []
        perlin_ seed = perlin seed 5 0.3 0.1

-- | A very simple plains biome made
-- out of "Blobk of Wood", "Item of Wood"
-- and "Air"
simplePlain :: SimpleBiome
simplePlain = SBiome cpmMap perlin_ stdMult
    where
        cpmMap value
          | value < 60 = T.Tile (TT.TBlock B.Air) []
          | value < 80 = T.Tile (TT.TItem I.Wood) []
          | otherwise  = T.Tile (TT.TBlock B.Wood) []
        perlin_ seed = perlin seed 5 0.3 0.1

-- | A WorldState is made of a Seed, a Name of the World
-- and a list of modified tiles and its coordinates.
data WorldState = World Seed String [CTile]

-- | Loads a Chunk from the chunk coordinates, a simple biome for
-- the chunk and the world state.
loadSBiomeChunk :: ChunkCoord -> SimpleBiome -> WorldState -> Chunk
loadSBiomeChunk cCoord sBiome (World seed _ tiles) = genSBiomeChunk seed cCoord sBiome // filter (\(x,_) -> isInChunkRange x cCoord) tiles

-- | A Simple Biome Map is like a Simple Biome, but
-- it returns a Simple Biome itself frmm a value in
-- a Perlin Map.
data SimpleBiomeMap = SBiomeM { cpmFuncM :: Int -> SimpleBiome  -- ^ Takes a value on the CPM
                              , perlinArgsM :: Int -> Perlin    -- ^ Takes a Seed by argument
                              , multiplierM :: Double           -- ^ Multiplier for all values
                              }

-- | A standart biome map.
stdBiomeMap :: SimpleBiomeMap
stdBiomeMap = SBiomeM cpmFM perlin_M stdMult
    where
        cpmFM value
          | value < 0 = simpleForest
          | otherwise = simplePlain
        perlin_M seed = perlin seed 5 0.01 0.001

-- | Loads a chunk from the chunk coordinates, a Simple Biome
-- Map and a World state.
loadSBiomeMChunk :: ChunkCoord -> SimpleBiomeMap -> WorldState -> Chunk
loadSBiomeMChunk (x,y) sBiomeM wState@(World seed _ _) = loadSBiomeChunk (x,y) sBiome wState
    where
        sBiome  = (cpmFuncM sBiomeM) (fromEnum value)
        value   = (multiplierM sBiomeM) * (twoD (toEnum x) (toEnum y) perlin_)
        perlin_ = (perlinArgsM sBiomeM) seed

-- | Loads a chunk using 'stdBiomeMap' in the
-- function 'loadSBiomeMChunk'.
loadChunk :: ChunkCoord -> WorldState -> Chunk
loadChunk cCoord wState = loadSBiomeMChunk cCoord stdBiomeMap wState

-- | Tile made of wood, for testing purposes.
woodTile :: T.Tile
woodTile = T.Tile (TT.TBlock B.Wood) []
